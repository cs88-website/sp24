class BaseAccount:
    """Create named accounts with a balance that is
    - increased by account_deposit
    - decreased by account_withdrawl
    """

    # Constructor
    def __init__(self, name, initial_deposit=0, account_number=0, bank=None):
        # Initialize the instance attributes
        self._name = name
        self._bank = bank
        self._acct_no = account_number
        self._balance = initial_deposit

    # Selectors
    def account_name(self):
        return self._name

    def account_balance(self):
        return self._balance

    def account_number(self):
        return self._acct_no

    # Operations
    def deposit(self, amount):
        self._balance += amount
        return self._balance

    def withdraw(self, amount):
        self._balance -= amount
        return self._balance

    def account_type(self):
        return "Base"

    # Display representation
    def __repr__(self):
        return f'<{self.account_type()}Account: {self.account_name()}-{self.account_number()}>'

    # Print representation
    def __str__(self):
        return f'{self.account_type()}Account: {self.account_name()}-{self.account_number()} Balance: {self._balance}'

    # This is only useful for debugging.
    def show_superclass(self):
        return super()

class CheckingAccount(BaseAccount):

    def __init__(self, name, initial_deposit, account_number=0, bank=None):
        # Use superclass initializer
        # BaseAccount.__init__(self, name, initial_deposit, account_number, bank)
        # Alternatively, recommended:
        super().__init__(name, initial_deposit, account_number, bank)
        # Additional initialization

    def withdraw(self, amount):
        """
        Adapt the withdraw methods to prevent "overdrafting"
        """
        if self.account_balance() - amount < 0:
            return "ERROR: You are not allowed to overdraft a CheckingAccount."
        return super().withdraw(amount)

    def account_type(self):
        return "Checking"

    # Just for debugging / example:
    def show_superclass(self):
        return super()

class SavingsAccount(BaseAccount):
    interest_rate = 0.02

    def __init__(self, name, initial_deposit, account_number=0, bank=None):
        # Use superclass initializer
        super().__init__(name, initial_deposit, account_number, bank)

    def accrue_interest(self):
        # We should use `self.interest_rate` so the RetirementSavingsAccount works
        self._balance = self._balance * (1 + self.interest_rate)

    def account_type(self):
        return "Savings"

    # Display representation
    def __repr__(self):
        # Alternatively, we can use `type(self)` to infer the class.
        return f'<{self.account_type()}Account: {self.account_name()}-{self.account_number()} @ {type(self).interest_rate * 100}%>'


class RetirementSavingsAccount(SavingsAccount):
    interest_rate = 0.05

    def withdraw(self, amount):
        return f"ERROR: You cannot withdraw from a {self.account_type()}."

    def account_type(self):
        return "RetirementSavings"

class Bank:
    def __init__(self, name, initial_account_number=1000):
        self.name = name
        self.__next_account_no = initial_account_number
        self.__accounts = []

    def new_account(self, name, initial_deposit=0, account_type=CheckingAccount):
        account_no = self.__next_account_no
        account = account_type(name, initial_deposit, account_no, self)
        self.__next_account_no += 1
        self.__accounts.append(account)
        return account

    def show_accounts(self):
        for acct in self.__accounts:
            print(acct)

    def all_accounts(self):
        return tuple(self.__accounts)

    # This allows us to write len(bank)
    def __len__(self):
        return len(self.__accounts)

    def total_assets(self):
        return sum(map(lambda a: a.account_balance(), self.__accounts))

    def __str__(self):
        return f"Bank of {self.name} with {len(self)} accounts."

    def account_types():
        return {
            'Checking': CheckingAccount,
            'Savings': SavingsAccount,
            'RetirementSavings': RetirementSavingsAccount
        }

#berkeley = Bank('UC Berkeley')
#cs88 = berkeley.new_account('CS88', 1000, CheckingAccount)
#cs61a = berkeley.new_account('CS61A', 1, SavingsAccount)

#berkeley.new_account('CS88 Retirement', 1000, RetirementSavingsAccount)

# Now we can find an account:
#retirement = berkeley.all_accounts()[-1]

# What kinds of accounts exist in our bank?
#Bank.account_types()




## Example Recursion + HOFs Problem

## While a recursive function which applies the
## argument `func` n times.
## `func` is a 2 argument function like add, mul, etc.
## This example was generated by ChatGPT with the prompt
## "Do you have an example of a recursive problem that uses a higher order function"
def apply_func(func, n):
    if n == 0:
        return 1
    else:
        return func(n, apply_func(func, n-1))

def multiply(x, y):
    return x * y

# Finding the factorial of 5 using the higher-order function
result = apply_func(multiply, 5)
print(result) # Output should be 120


### (Aside): ChatGPT's version isn't good for
## adding values...
### Try this deriviative:
### This is because when adding we want to start from 0.
def apply_func(func, n, base=1):
    if n == 0:
        return base
    else:
        return func(n, apply_func(func, n-1, base))

apply_func(lambda x, y: x + y, 10, base=0)
